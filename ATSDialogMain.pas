////////////////////////////////////////////////////////////////////////////////
//             ATSTest - иллюстрация комплексной обработки исключений
//                             (c) Николай Мазуркин
//    http://mazurkin.virtualave.net, mazurkin@mailru.com, mazurkin@chat.ru
// _____________________________________________________________________________
//                                 Главная форма
////////////////////////////////////////////////////////////////////////////////

unit ATSDialogMain;

interface

uses
  Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs,
  StdCtrls, ExtCtrls;

type
  TDialogMain = class(TForm)
    btnErrorRaise: TButton;
    rgrpErrorType: TRadioGroup;
    procedure OnRaiseError(Sender: TObject);
  protected
    procedure ErrorPointer;
    procedure ErrorExceptionUnhandled;  
    procedure ErrorExceptionHandled;
    procedure ErrorAPI;
    procedure ErrorUnhandled;
    procedure ErrorHandled;
    procedure ErrorAssert;
    function  ErrorFunction: Integer;
  end;

var
  DialogMain: TDialogMain;

implementation

uses ATSAssert;

{$R *.DFM}

////////////////////////////////////////////////////////////////////////////////
// Генерирование ошибки
////////////////////////////////////////////////////////////////////////////////
procedure TDialogMain.OnRaiseError(Sender: TObject);
begin
  try
    // Генерируем ошибку, которую требует пользователь
    case rgrpErrorType.ItemIndex of
      0 : ErrorPointer;
      1 : ErrorExceptionUnhandled;
      2 : ErrorExceptionHandled;
      3 : ErrorAPI;
      4 : ErrorUnhandled;
      5 : ErrorHandled;
      6 : ErrorAssert;
      7 : ErrorFunction;
    end;
    // В данной процедуре не может возникать никаких ошибок и исключений. Однако
    // необработанные исключения могут возникать в дочерних вызываемых процедурах.
    // Обработчик в этой процедуре предназначен для отлова всех необработанных исключений,
    // которые могут проходить "наверх" вследствие неаккуратности или забывчивости.
    // В данном случае локализация ошибки станет несколько более трудной, так как
    // к рассмотрению должны быть приняты все вызываемые процедуры.
  except
    raise AssertInternal('{97D33BA0-2A45-11D4-ACD0-009027350D25}');
  end;
end;

////////////////////////////////////////////////////////////////////////////////
// Обработка ошибок от "бешеного" указателя
////////////////////////////////////////////////////////////////////////////////
procedure TDialogMain.ErrorPointer;
var
  WrongPointer : PInteger;
begin
  try
    // Присваиваем гипотетическому указателю неверный адрес (ошибочная ситуация)
    WrongPointer  := nil;
    // Пытаемся записать по этому адресу какое-либо значение
    // Генерируется исключение, которорое перехватывается нашим обработчиком
    // Можно легко локализовать ошибку.
    WrongPointer^ := 100;
  except
    raise AssertInternal('{97D33BA1-2A45-11D4-ACD0-009027350D25}');
  end;
end;

////////////////////////////////////////////////////////////////////////////////
// Необрабатываемое открытие файла (надежная функция)
////////////////////////////////////////////////////////////////////////////////
procedure TDialogMain.ErrorExceptionUnhandled;
var
  FS : TFileStream;
begin
  try
    // Открываем несуществующий файл (ошибочная ситуация), причем мы уверены, что
    // он должен открыться нормально (надежная функция) и не хотим предпринимать никаких
    // действий по обработке ошибок.
    // Возникает исключение, которое перехватывается нашим обработчиком.
    FS := TFileStream.Create('qgfasajasasasa.das', fmOpenRead);
    // Эти фукнции не выполняются, т.к. файл не может быть открыт
    FS.Seek(0, 0);
    FS.Free;
    // Традиционно, в таких структурах используется конструкция
    //    FS := TFileStream.Create('qgfasajasasasa.das', fmOpenRead);
    //    try
    //      FS.Seek(0, 0);
    //    finally
    //      FS.Free;
    //    end;
    // Однако, так как мы используем понятие "фатальной" ошибки и строчка FS.Seek(0, 0)
    // генерирует именно такую ошибку приводящую к завершению программы, никаких
    // действий по освобождению занятой памяти предпринимать не нужно - программа все 
    // равно будет закрыта.
  except
    raise AssertInternal('{97D33BA3-2A45-11D4-ACD0-009027350D25}');
  end;
end;

////////////////////////////////////////////////////////////////////////////////
// Обрабатываемое открытие файла (ненадежная функция)
////////////////////////////////////////////////////////////////////////////////
procedure TDialogMain.ErrorExceptionHandled;
var
  FS : TFileStream;
begin
  try
    // Открываем несуществующий файл (ошибочная ситуация), причем мы не уверены, что
    // он должен будет открыт (ненадежная функция). Мы устанавливаем дополнительный
    // обработчик, который перехватывает, обрабатывает возникшую ошибку и выдает сообщение.
    try
      FS := TFileStream.Create('qgfasajasasasa.das', fmOpenRead);
    except
      ShowMessage('Невозможно открыть файл такой-то, выполните то-то.');
      Exit;
    end;
    // Эти фукнции не выполняются, т.к. файл не может быть открыт
    FS.Seek(0, 0);
    FS.Free;
  except
    raise AssertInternal('{97D33BA2-2A45-11D4-ACD0-009027350D25}');
  end;
end;

////////////////////////////////////////////////////////////////////////////////
// Обработка ошибок API
////////////////////////////////////////////////////////////////////////////////
procedure TDialogMain.ErrorAPI;
var
  SomeHandle : THandle;
begin
  try
    // Присваиваем гипотетическому дескриптору неверное значение (ошибочная ситуация)
    SomeHandle := INVALID_HANDLE_VALUE;
    // Проверяем результат выполнения API-функции и, если-что, выводим фатальную ошибку 
    AssertWin32(CloseHandle(SomeHandle), '{97D33BA5-2A45-11D4-ACD0-009027350D25}');
    // В данной процедуре не может возникнуть никаких исключений и, на первый взгляд,
    // не вызываются функции в которых исключение может возникать. Однако, исключение
    // все таки может возникнуть и в API-функции (например при обращении к памяти), и,
    // во-вторых, хорошим стилем будет введение обработчика во все процедуры, т.к. возможно
    // их исправление, модификация и пр., в ходе которых могут появиться опасные участки кода.
  except
    raise AssertInternal('{97D33BA4-2A45-11D4-ACD0-009027350D25}');
  end;
end;

////////////////////////////////////////////////////////////////////////////////
// Проверка аргументов и внутренних переменных
////////////////////////////////////////////////////////////////////////////////
procedure TDialogMain.ErrorAssert;
begin
  try
    // Проверяем заведомо неправильное условие имитируя ошибочную ситуацию.
    AssertMsg(Self = nil, '{CFCC0842-2A5C-11D4-ACD0-009027350D25}');
    // То же самое. Хотя в этой процедуре не может возникнуть исключений, обработчик
    // поставлен с учетом дальнейшего возможного расширения процедуры.
  except
    raise AssertInternal('{97D33BA7-2A45-11D4-ACD0-009027350D25}');
  end;
end;

////////////////////////////////////////////////////////////////////////////////
// Необрабытываемая ошибка
////////////////////////////////////////////////////////////////////////////////
procedure TDialogMain.ErrorUnhandled;
var
  Strs : TStringList;
begin
  // В данной функции мы "забыли" о комплексной обработке ошибок и стали программировать
  // в традиционном стиле.
  // Возникающее в этой процедуре исключение не обрабатывается локально, однако оно
  // обрабатывается в процедуре, которая вызвала данную процедуру. Локализация стала
  // более трудной.
  // Если мы забывчивы настолько, что на пути исключения не будет ни одного обработчика
  // исключение будет обработано глобальным обработчиком исключений на событии
  // TApplication.OnException - однако о локализации ошибки уже не может быть и речи.
  Strs := TStringList.Create;
  try
    Strs.Strings[10];
  finally
    Strs.Free;
  end;
end;

////////////////////////////////////////////////////////////////////////////////
// Обрабатываемая ошибка
////////////////////////////////////////////////////////////////////////////////
procedure TDialogMain.ErrorHandled;
var
  Strs : TStringList;
begin
  // Предыдущий пример - однако, в стиле комплексной обработки ошибок.
  try
    Strs := TStringList.Create;
    Strs.Strings[10];
    Strs.Free;
  except
    raise AssertInternal('{97D33BA6-2A45-11D4-ACD0-009027350D25}');
  end;
end;

////////////////////////////////////////////////////////////////////////////////
// Функция с ошибкой
////////////////////////////////////////////////////////////////////////////////
function TDialogMain.ErrorFunction: Integer;
begin
  try
    // Проверяем заведомо ложное утверждение
    AssertMsg(1 = 2, '{CFCC0844-2A5C-11D4-ACD0-009027350D25}');
    // Присваиваем значение результатирующей переменной
    Result := 0;
    // Данный пример иллюстрирует необходимость пременения синтаксиса
    //   raise AssertInternal(..)
    // вместо просто
    //   AssertInternal(..);
    // На самом деле вставлять оператор raise нет никакой необходимости,
    // так как он все рано не выполняется, а программа завершается в вызываемой
    // функции AssertInternal. Однако, без указания оператора raise, компилятор
    // будет выдавать многочисленные предупреждения, так как по его мнению, это вполне
    // обычная процедура, которая вызывается обычным образом. И в этом случае результат
    // функции действительно был бы неопределен.  
  except
    raise AssertInternal('{CFCC0843-2A5C-11D4-ACD0-009027350D25}');
  end;
end;

end.
